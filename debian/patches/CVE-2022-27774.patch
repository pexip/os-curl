From: Markus Koschany <apo@debian.org>
Date: Thu, 28 Jul 2022 14:17:33 +0200
Subject: CVE-2022-27774

Bug-Debian: https://bugs.debian.org/1010254
Origin: https://github.com/curl/curl/commit/620ea21410030a9977396b4661806bc187231b79
Origin: https://github.com/curl/curl/commit/139a54ed0a172adaaf1a78d6f4fff50b2c3f9e08
---
 lib/connect.c      |  1 +
 lib/http.c         | 10 +++++-----
 lib/http.h         |  6 ++++++
 lib/transfer.c     | 48 +++++++++++++++++++++++++++++++++++++++++++++++-
 lib/urldata.h      |  1 +
 lib/vtls/openssl.c |  3 ++-
 6 files changed, 62 insertions(+), 7 deletions(-)

diff --git a/lib/connect.c b/lib/connect.c
index e65d24d..0f122ce 100644
--- a/lib/connect.c
+++ b/lib/connect.c
@@ -611,6 +611,7 @@ void Curl_persistconninfo(struct connectdata *conn)
   conn->data->info.conn_scheme = conn->handler->scheme;
   conn->data->info.conn_protocol = conn->handler->protocol;
   conn->data->info.conn_primary_port = conn->primary_port;
+  conn->data->info.conn_remote_port = conn->remote_port;
   conn->data->info.conn_local_port = conn->local_port;
 }
 
diff --git a/lib/http.c b/lib/http.c
index bf78eb2..35ec7c5 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -752,10 +752,10 @@ output_auth_headers(struct connectdata *conn,
 }
 
 /*
- * allow_auth_to_host() tells if autentication, cookies or other "sensitive
- * data" can (still) be sent to this host.
+ * Curl_allow_auth_to_host() tells if authentication, cookies or other
+ * "sensitive data" can (still) be sent to this host.
  */
-static bool allow_auth_to_host(struct Curl_easy *data)
+bool Curl_allow_auth_to_host(struct Curl_easy *data)
 {
   struct connectdata *conn = data->conn;
   return (!data->state.this_is_a_follow ||
@@ -839,7 +839,7 @@ Curl_http_output_auth(struct connectdata *conn,
 
   /* To prevent the user+password to get sent to other than the original host
      due to a location-follow */
-  if(allow_auth_to_host(data)
+  if(Curl_allow_auth_to_host(data)
      || conn->bits.netrc
   )
     result = output_auth_headers(conn, authhost, request, path, FALSE);
@@ -1814,7 +1814,7 @@ CURLcode Curl_add_custom_headers(struct connectdata *conn,
                    checkprefix("Cookie:", compare)) &&
                   /* be careful of sending this potentially sensitive header to
                      other hosts */
-                  !allow_auth_to_host(data))
+                  !Curl_allow_auth_to_host(data))
             ;
           else {
             result = Curl_dyn_addf(req, "%s\r\n", compare);
diff --git a/lib/http.h b/lib/http.h
index 1aaec22..49fcb3d 100644
--- a/lib/http.h
+++ b/lib/http.h
@@ -252,4 +252,10 @@ Curl_http_output_auth(struct connectdata *conn,
                       bool proxytunnel); /* TRUE if this is the request setting
                                             up the proxy tunnel */
 
+/*
+ * Curl_allow_auth_to_host() tells if authentication, cookies or other
+ * "sensitive data" can (still) be sent to this host.
+ */
+bool Curl_allow_auth_to_host(struct Curl_easy *data);
+
 #endif /* HEADER_CURL_HTTP_H */
diff --git a/lib/transfer.c b/lib/transfer.c
index b8c3bcb..3f21c76 100644
--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -1645,10 +1645,56 @@ CURLcode Curl_follow(struct Curl_easy *data,
       return CURLE_OUT_OF_MEMORY;
   }
   else {
-
     uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl, 0);
     if(uc)
       return Curl_uc_to_curlcode(uc);
+
+    /* Clear auth if this redirects to a different port number or protocol,
+       unless permitted */
+    if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {
+      char *portnum;
+      int port;
+      bool clear = FALSE;
+
+      if(data->set.use_port && data->state.allow_port)
+        /* a custom port is used */
+        port = (int)data->set.use_port;
+      else {
+        uc = curl_url_get(data->state.uh, CURLUPART_PORT, &portnum,
+                          CURLU_DEFAULT_PORT);
+        if(uc) {
+          free(newurl);
+          return Curl_uc_to_curlcode(uc);
+        }
+        port = atoi(portnum);
+        free(portnum);
+      }
+      if(port != data->info.conn_remote_port) {
+        infof(data, "Clear auth, redirects to port from %u to %u",
+              data->info.conn_remote_port, port);
+        clear = TRUE;
+      }
+      else {
+        char *scheme;
+        const struct Curl_handler *p;
+        uc = curl_url_get(data->state.uh, CURLUPART_SCHEME, &scheme, 0);
+        if(uc) {
+          free(newurl);
+          return Curl_uc_to_curlcode(uc);
+        }
+
+        p = Curl_builtin_scheme(scheme);
+        if(p && (p->protocol != data->info.conn_protocol)) {
+          infof(data, "Clear auth, redirects scheme from %s to %s",
+                data->info.conn_scheme, scheme);
+          clear = TRUE;
+        }
+        free(scheme);
+      }
+      if(clear) {
+        Curl_safefree(data->state.aptr.userpwd);
+      }
+    }
   }
 
   if(type == FOLLOW_FAKE) {
diff --git a/lib/urldata.h b/lib/urldata.h
index d9d441e..044c840 100644
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -1148,6 +1148,7 @@ struct PureInfo {
 
   char conn_primary_ip[MAX_IPADR_LEN];
   long conn_primary_port;
+  long conn_remote_port;
   char conn_local_ip[MAX_IPADR_LEN];
   long conn_local_port;
   const char *conn_scheme;
diff --git a/lib/vtls/openssl.c b/lib/vtls/openssl.c
index 794e297..31c7386 100644
--- a/lib/vtls/openssl.c
+++ b/lib/vtls/openssl.c
@@ -2857,7 +2857,8 @@ static CURLcode ossl_connect_step1(struct connectdata *conn, int sockindex)
 #endif
 
 #ifdef USE_OPENSSL_SRP
-  if(ssl_authtype == CURL_TLSAUTH_SRP) {
+  if((ssl_authtype == CURL_TLSAUTH_SRP) &&
+     Curl_allow_auth_to_host(data)) {
     char * const ssl_username = SSL_SET_OPTION(primary.username);
     char * const ssl_password = SSL_SET_OPTION(primary.password);
 
