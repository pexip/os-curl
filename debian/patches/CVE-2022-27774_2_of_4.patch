The following sequence of patches is based on these upstream commits:
https://github.com/curl/curl/commit/08b8ef4e726ba10f45081ecda5b3cea788d3c839
https://github.com/curl/curl/commit/620ea21410030a9977396b4661806bc187231b79
https://github.com/curl/curl/commit/5295e8d64ac6949ecb3f9e564317a608f51b90d8
https://github.com/curl/curl/commit/139a54ed0a172adaaf1a78d6f4fff50b2c3f9e08

It is further based on work by Kamil Dudka <kdudka@redhat.com> for
CentOS 8 and CentOS 9:
https://gitlab.com/redhat/centos-stream/rpms/curl/-/blob/c9s/0013-curl-7.76.1-CVE-2022-27774.patch
https://gitlab.com/redhat/centos-stream/rpms/curl/-/blob/c8s/0038-curl-7.61.1-CVE-2022-27774.patch


From 620ea21410030a9977396b4661806bc187231b79 Mon Sep 17 00:00:00 2001
From: Daniel Stenberg <daniel@haxx.se>
Date: Mon, 25 Apr 2022 16:24:33 +0200
Subject: [PATCH] transfer: redirects to other protocols or ports clear auth

... unless explicitly permitted.

Bug: https://curl.se/docs/CVE-2022-27774.html
Reported-by: Harry Sintonen
Closes #8748
---
 lib/transfer.c |   48 +++++++++++++++++++++++++++++++++++++++++++++++-
 lib/url.c      |   35 +++++++++++++++++++++--------------
 lib/urldata.h  |    1 +
 3 files changed, 69 insertions(+), 15 deletions(-)

--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -1467,6 +1467,7 @@
   data->state.wildcardmatch = data->set.wildcard_enabled;
   data->set.followlocation = 0; /* reset the location-follow counter */
   data->state.this_is_a_follow = FALSE; /* reset this */
+  data->state.this_is_a_follow_without_auth = FALSE;
   data->state.errorbuf = FALSE; /* no error has occurred */
   data->state.httpversion = 0; /* don't assume any particular server version */
 
@@ -1645,10 +1646,55 @@
       return CURLE_OUT_OF_MEMORY;
   }
   else {
-
     uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl, 0);
     if(uc)
       return Curl_uc_to_curlcode(uc);
+
+    /* Clear auth if this redirects to a different port number or protocol,
+       unless permitted */
+    if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {
+      char *portnum;
+      int port;
+      bool clear = FALSE;
+
+      if(data->set.use_port && data->state.allow_port)
+        /* a custom port is used */
+        port = (int)data->set.use_port;
+      else {
+        uc = curl_url_get(data->state.uh, CURLUPART_PORT, &portnum,
+                          CURLU_DEFAULT_PORT);
+        if(uc) {
+          free(newurl);
+          return Curl_uc_to_curlcode(uc);
+        }
+        port = atoi(portnum);
+        free(portnum);
+      }
+      if(port != data->info.conn_remote_port) {
+        infof(data, "Clear auth, redirects to port from %u to %u",
+              data->info.conn_remote_port, port);
+        clear = TRUE;
+      }
+      else {
+        char *scheme;
+        const struct Curl_handler *p;
+        uc = curl_url_get(data->state.uh, CURLUPART_SCHEME, &scheme, 0);
+        if(uc) {
+          free(newurl);
+          return Curl_uc_to_curlcode(uc);
+        }
+
+        p = Curl_builtin_scheme(scheme);
+        if(p && (p->protocol != data->info.conn_protocol)) {
+          infof(data, "Clear auth, redirects scheme from %s to %s",
+                data->info.conn_scheme, scheme);
+          clear = TRUE;
+        }
+        free(scheme);
+      }
+      if(clear)
+        data->state.this_is_a_follow_without_auth = TRUE;
+    }
   }
 
   if(type == FOLLOW_FAKE) {
--- a/lib/url.c
+++ b/lib/url.c
@@ -2819,22 +2819,29 @@
     conn->bits.user_passwd = FALSE; /* disable user+password */
   }
 
-  if(data->set.str[STRING_USERNAME]) {
-    free(*userp);
-    *userp = strdup(data->set.str[STRING_USERNAME]);
-    if(!*userp)
-      return CURLE_OUT_OF_MEMORY;
-    conn->bits.user_passwd = TRUE; /* enable user+password */
-    user_changed = TRUE;
+  if(data->state.this_is_a_follow
+      && data->state.this_is_a_follow_without_auth)
+  {
+    conn->bits.user_passwd = FALSE;
   }
+  else {
+    if(data->set.str[STRING_USERNAME]) {
+      free(*userp);
+      *userp = strdup(data->set.str[STRING_USERNAME]);
+      if(!*userp)
+        return CURLE_OUT_OF_MEMORY;
+      conn->bits.user_passwd = TRUE; /* enable user+password */
+      user_changed = TRUE;
+    }
 
-  if(data->set.str[STRING_PASSWORD]) {
-    free(*passwdp);
-    *passwdp = strdup(data->set.str[STRING_PASSWORD]);
-    if(!*passwdp)
-      return CURLE_OUT_OF_MEMORY;
-    conn->bits.user_passwd = TRUE; /* enable user+password */
-    passwd_changed = TRUE;
+    if(data->set.str[STRING_PASSWORD]) {
+      free(*passwdp);
+      *passwdp = strdup(data->set.str[STRING_PASSWORD]);
+      if(!*passwdp)
+        return CURLE_OUT_OF_MEMORY;
+      conn->bits.user_passwd = TRUE; /* enable user+password */
+      passwd_changed = TRUE;
+    }
   }
 
   if(data->set.str[STRING_OPTIONS]) {
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -1440,6 +1440,7 @@
   BIT(multi_owned_by_easy);
 
   BIT(this_is_a_follow); /* this is a followed Location: request */
+  BIT(this_is_a_follow_without_auth);
   BIT(refused_stream); /* this was refused, try again */
   BIT(errorbuf); /* Set to TRUE if the error buffer is already filled in.
                     This must be set to FALSE every time _easy_perform() is
